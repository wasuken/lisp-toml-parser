(defpackage toml-parser
  (:use :cl)
  (:export :parse :toml-key-list :toml-value-list
		   :toml-reset :deep-hashtable-to-plist
		   :hashtable-values :hashtable-keys))
(in-package :lisp-toml-parser)

(defparameter *toml* (make-hash-table))

(defparameter *name-space* "")

(defun hashtable-keys (ht)
  (let ((result '()))
	(maphash #'(lambda (k v) (push k result))
			 ht)
	(reverse result)))

(defun hashtable-values (ht)
  (let ((result '()))
	(maphash #'(lambda (k v) (push v result))
			 ht)
	(reverse result)))

(defun toml-reset ()
  (setf *toml* (make-hash-table)))

(defun toml-key-list ()
  (hashtable-keys *toml*))

(defun toml-value-list ()
  (hashtable-values *toml*))

(defun deep-hashtable-to-plist (table)
  (let ((keys (hashtable-keys table))
		(values (hashtable-values table)))
	(mapcar #'(lambda (k v)
				(cond ((hash-table-p v)
					   (cons k (deep-hashtable-to-plist v)))
					  (t
					   (cons k v))))
			keys
			values)))

(defun varies-with-type (str)
  (let ((junk-rem-and-downcase-str (string-trim '(#\Space) (string-downcase str))))
	(cond
	  ((string= junk-rem-and-downcase-str "true") t)
	  ((string= junk-rem-and-downcase-str "false") nil)
	  ((ppcre:scan-to-strings "^[0-9][0-9|\.]+$" junk-rem-and-downcase-str)
	   (parse-float:parse-float junk-rem-and-downcase-str))
	  ((ppcre:scan-to-strings "^[0-9]+$" junk-rem-and-downcase-str)
	   (parse-integer junk-rem-and-downcase-str))
	  ((ppcre:scan-to-strings "^\".*?\"" junk-rem-and-downcase-str)
	   (ppcre:register-groups-bind (n)
		   ("\"(.*?)\"" junk-rem-and-downcase-str)
		 n))
	  (t junk-rem-and-downcase-str))))

(defun str-extract-array-str (str)
  (let ((result "")
		(lparen 1))
	(loop for c across (subseq str 1)
	   while (> lparen 0)
	   do (progn
			(setf result (concatenate 'string result `(,c)))
			(cond ((eql c #\[)
				   (incf lparen))
				  ((eql c #\])
				   (decf lparen)))))
	(concatenate 'string "[" result)))

(defun tree-remove-if (tree tar &optional (test 'eql))
  (cond ((null tree) nil)
		((not (listp (car tree)))
		 (if (eval `(,test ,(car tree) ,tar))
			 (tree-remove-if (cdr tree) tar test)
			 (append (list (car tree))
					 (tree-remove-if (cdr tree) tar test))))
		((null (car tree)) (tree-remove-if (cdr tree) tar test))
		((null (cdr tree)) (list (tree-remove-if (car tree) tar test)))
		(t (append (list (tree-remove-if (car tree) tar test))
				   (tree-remove-if (cdr tree) tar test)))))

(defun tree-change-str->split-lst (tree)
  (cond ((null tree) nil)
		((not (listp (car tree)))
		 (if (ppcre:scan-to-strings "," (ppcre:regex-replace-all "\".*?\"" (car tree) ""))
			 (append (mapcar #'varies-with-type (ppcre:split "," (string-trim '(#\Space) (car tree))))
					 (tree-change-str->split-lst (cdr tree)))
			 (cons (varies-with-type (string-trim '(#\Space) (car tree)))
				   (tree-change-str->split-lst (cdr tree)))))
		((null (car tree)) (tree-change-str->split-lst (cdr tree)))
		((null (cdr tree)) (list (tree-change-str->split-lst (car tree))))
		(t (append (list (tree-change-str->split-lst (car tree)))
				   (tree-change-str->split-lst (cdr tree))))))

(defun str->node-and-after-reduction (str)
  (cond ((ppcre:scan-to-strings "^\\[" str)
		 (let* ((array-str (str-extract-array-str str))
				(array-lst (tree-remove-if
							(nth 2
								 (nth 3
									  (chtml:parse (ppcre:regex-replace-all "\\]"
																			(ppcre:regex-replace-all "\\[" array-str "<a>")
																			"</a>")
												   (chtml:make-lhtml-builder))))
							:a)))
		   (cons (tree-change-str->split-lst array-lst)
				 (if (>= (length str) (1+ (length array-str)))
					 (subseq str (1+ (length array-str)))))))
		((ppcre:scan-to-strings "^\\d{4}-\\d{2}-\\d{2}" str)
		 (cons (ppcre:scan-to-strings "^\\d{4}-\\d{2}-\\d{2}" str)
			   (ppcre:regex-replace-all "^\\d{4}-\\d{2}-\\d{2}" str "")))
		((ppcre:scan-to-strings "^=" str)
		 (cons (ppcre:scan-to-strings "^=" str)
			   (ppcre:regex-replace-all "^=" str "")))
		((ppcre:scan-to-strings "^\"" str)
		 (cons (ppcre:scan-to-strings "^\".*?\"" str)
			   (ppcre:regex-replace-all "^\".*?\"" str "")))
		((ppcre:scan-to-strings "^[0-9]" str)
		 (cons (parse-integer (ppcre:scan-to-strings "^[0-9]+" str))
			   (ppcre:regex-replace-all "^[0-9]+" str "")))
		((string= "true" (string-downcase (ppcre:scan-to-strings "^\\w+" str)))
		 (cons t (ppcre:regex-replace-all  "^\\w+" str "")))
		((string= "false" (string-downcase (ppcre:scan-to-strings "^\\w+" str)))
		 (cons nil (ppcre:regex-replace-all "^\\w+" str "")))
		((ppcre:scan-to-strings "^\\w+" str)
		 (cons (ppcre:scan-to-strings "^\\w+" str)
			   (ppcre:regex-replace-all "^\\w+" str "")))
		(t (cons (ppcre:scan-to-strings "^\\S+" str)
				 (ppcre:regex-replace-all "^\\S+" str "")))))

(defun base-parse (str namespace)
  (let* ((new-namespace (if (ppcre:scan-to-strings "^\\[.*?\\]" (string-trim '(#\Space) str))
							(ppcre:scan-to-strings "^\\[.*?\\]" (string-trim '(#\Space) str))
							namespace))
		 (replaced-str (ppcre:regex-replace-all "^\\[.*?\\]" (string-trim '(#\Space) str) "")))
	(if (and (stringp replaced-str) (string= replaced-str ""))
		nil
		(let* ((left-and-ar (str->node-and-after-reduction
							 (string-trim '(#\Space #\Newline) replaced-str)))
			   (middle-and-ar (str->node-and-after-reduction
							   (string-trim '(#\Space #\Newline) (cdr left-and-ar))))
			   (right-and-ar (str->node-and-after-reduction
							  (string-trim '(#\Space #\Newline) (cdr middle-and-ar)))))
		  ;; (print left-and-ar)
		  ;; (print middle-and-ar)
		  ;; (print right-and-ar)
		  (when (or (null (car left-and-ar)) (null (car middle-and-ar)) (string= "" (cdr middle-and-ar)))
			(error "syntax error"))
		  (cons new-namespace
				(cons (list (car left-and-ar)
							(car middle-and-ar)
							(if (and (stringp (car right-and-ar))
									 (ppcre:scan-to-strings "\"" (car right-and-ar)))
								(ppcre:regex-replace-all "\"" (car right-and-ar) "")
								(car right-and-ar)))
					  (if (cdr right-and-ar)
						  (base-parse (cdr right-and-ar) new-namespace))))
		  ))))

(defun parens-check (str)
  (let* ((replaced-str (ppcre:regex-replace-all "\".*?\"" str ""))
		 (square-lbrackets-cnt (count-if #'(lambda (x) (eql x #\[)) replaced-str))
		 (square-rbrackets-cnt (count-if #'(lambda (x) (eql x #\])) replaced-str))
		 (two-or-more-equals (ppcre:scan-to-strings "==+" replaced-str)))
	(when (not (= square-lbrackets-cnt square-rbrackets-cnt))
	  (error "The left and right square brackets do not match."))
	(when two-or-more-equals
	  (error "two or more equals."))))

(defun deep-namespace (table namespaces)
  (unless (gethash (intern (car namespaces)) table)
	  (setf (gethash (intern (car namespaces)) table)
			(make-hash-table)))
  (if (cdr namespaces)
	  (deep-namespace (gethash (intern (car namespaces)) table)
					  (cdr namespaces))
	  (gethash (intern (car namespaces)) table)))

(defun parse-method (lst)
  (when lst
	(cond ((null (car lst))
			 (setf (gethash (intern (if (integerp (car (car (cdr lst))))
										(write-to-string (car (car (cdr lst))))
										(car (car (cdr lst)))))
							*toml*)
				   (nth 2 (car (cdr lst)))))
		  (t
		   (let* ((namespace (ppcre:regex-replace-all "\\[|\\]" (car lst) ""))
				  (namespaces (ppcre:split "\\." namespace)))
			 (cond ((= (length namespaces) 1)
					(unless (gethash (intern namespace) *toml*)
					  (setf (gethash (intern namespace) *toml*) (make-hash-table)))
					(setf (gethash (intern (if (integerp (car (car (cdr lst))))
											   (write-to-string (car (car (cdr lst))))
											   (car (car (cdr lst)))))
								   (gethash (intern namespace) *toml*))
						  (nth 2 (car (cdr lst)))))
				   (t
					(let ((table (deep-namespace *toml* namespaces)))
					  (setf (gethash (intern (if (integerp (car (car (cdr lst))))
												 (write-to-string (car (car (cdr lst))))
												 (car (car (cdr lst)))))
									 table)
							(nth 2 (car (cdr lst))))))))))
	(parse-method (nthcdr 2 lst))))

(defun parse (str)
  (parens-check str)
  (let* ((nodes (base-parse str nil)))
	(parse-method nodes)
	*toml*))
